---
layout: post
title: HTTP权威指南整理(持续更新)
date: 2019-04-11
keywords: git,githook,hexo
tags:
    - HTTP

categories:
    - HTTP
---
# HTTP权威指南整理(持续更新)

# 1.判断客户端

    ex01 微信端:
        req.headers['user-agent']&&req.headers['user-agent'].indexOf('MicroMessenger/')===-1

        headers:{"Authorization": "Bearer "+token}


# <span style='color:red'>2.POST与GET的区别</span>
<!-- more -->
>区别

- GET在浏览器回退时是无害的，而POST会再次提交请求。
- GET产生的URL地址可以被Bookmark，而POST不可以。
- GET请求会被浏览器主动cache，而POST不会，除非手动设置。
- GET请求只能进行url编码，而POST支持多种编码方式。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
- GET请求在URL中传送的参数是有长度限制的，而POST么有。
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
- GET参数通过URL传递，POST放在Request body中。
- GET产生一个TCP数据包；POST产生两个TCP数据包。
- 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
- 对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。
- 也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。
- 因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？
- - 1.GET与POST都有自己的语义，不能随便混用。
- - 2.据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。
- - 3.并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。

- GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。
- GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）； 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

- GET的语义是请求获取指定的资源。GET方法是安全、幂等、可缓存的（除非有 Cache-ControlHeader的约束）,GET方法的报文主体没有任何语义。
- POST的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。、POST不安全，不幂等，（大部分实现）不可缓存
- 为了针对其不可缓存性，有一系列的方法来进行优化。


# 3.get、post、put、delete 区别

    get、post、put、delete对应的是查、增、改、删

# 4.URL 统一资源定位器

>语法规则

    scheme://host.domain:port/path/filename

>说明：

    http://www.runoob.com/html/html-tutorial.html

    scheme - 定义因特网服务的类型，（http https ftp file）
    host -定义域主机（http默认www）
    domain -定义因特网域名，比如runoob.com
    :port - 定义主机上的端口号（http默认80 https默认443）
    path - 定义服务器上的路径

    为了传输很多的不安全的字符，url会对不安全的字符进行编码。
    字符限制:% / . .. # ?; : $,+ @ &={}|\^~[]''<> 还有大部分十六进制的不行



# 5.字节流报文流

    网络的OSI定义的7层里，最底层的物理层传输的是比特流(bit)、倒数第2数据链路层处理的是以帧(frame)为单位的，再往上就是网络层处理的单位是报文(message)，再往上是传输层，还是使用报文,传输层是上三层逻辑层与下三层物理层的一个中间层。
    每一层都会把前一层把数据处理打包一次，例如物理层传到数据链路层，数据链路层就会把比特处理打包成帧，网络层就会把帧处理打包成报文

# 6.HTTP报文

## 1.报文向下流动
    client->代理1->代理2->服务器->代理2->客户端

## 2.报文的组成部分

>对报文描述的起始行（start line）

>包含属性的首部（header）块，

>以及可选的包含数据主题的body部分。

    需要注意的是起始行和首部就是由行分隔的ASCII文本。每行都以一个两个字符组成的行终止序列符结束，其中包括一个回车符（ASCII 13）和一个换行符（ASCII 10）行终止序列符可以写作CRLF

    start line:HTTP/1.1 200 ok
    header:
        Content-type:text/plain
        Content-length:19
    body:Hi
### 2.1 报文的语法

    请求报文：
        <method><request-URL><version>
        <headers>
        <entity-body>

        GET /admin HTTP/1.1
        Accept:text/*
        Host:www.xxx.com

    响应报文:
        <version><status><reason-phrase> // reason-phrase状态码的文本描述
        <headers>
        <entity-body>
        HTTP/1.1 200 ok
        Content-type:text/plain
        Content-length:2
        hi
### 2.2 起始行

        所有的请求都以起始行作为开始。请求报文起始行说明了要做写什么。响应报文则说明了发生了什么。
        常用的的方法：
            GET 通过请求URI得到资源
            POST 用于添加新的内容
            PUT 用于修改某个内容
            DELETE 删除某个内容
            CONNECT 用于代理进行传输，如使用SSL
            OPTIONS 询问可以执行哪些方法
            PATCH 部分文档更改
            PROPFIND, (wedav) 查看属性
            PROPPATCH, (wedav) 设置属性
            MKCOL, (wedav) 创建集合（文件夹）
            COPY, (wedav) 拷贝
            MOVE, (wedav) 移动
            LOCK, (wedav) 加锁
            UNLOCK (wedav) 解锁
            TRACE 用于远程诊断服务器
            HEAD 类似于GET,但是不返回body信息，用于检查对象是否存在，以及得到对象的元数据


### 2.3 首部分类

    通用首部
        既可以出现在请求报文中，也可以出现在响应报文中
    请求首部
        提供更多有关的信息
    响应首部
        提供更多的有关响应的信息
    实体首部
        描述主体的长度和内容，或者资源自身
    扩展首部
        规范中没有定义的新首部

    首部实例：
        Content-length:15040  实体主体部分包含了15040个字节

### 2.4 方法

#### 2.4.1 HEAD方法

    HEAD方法和GET方法类似，但服务器在响应的中只返回首部。不会返回实体部分。这就允许客户端在未获取实际资源的情况下，对资源的首部进行检查。

#### 2.4.2 TRACE

    客户端发送一个请求，这个请求要穿过防火墙、代理、网关或者其他的一些应用。每个中间节点都可能修改原始的HTTP请求。
    TRACE主要用于诊断，也就是说用户验证请求是否如愿的穿过了请求/响应链。缺点很明显不能精确地区分 请求类型和方法。中间程序会自行决定对TRACE的处理方式

#### 2.4.3 OPTIONS

    OPTIONS方法请求Web服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法。

#### 2.4.4 扩展方法

    并不是所有的扩展方法都在规范中，所以不一定都支持。
    LOCK
    MKCOOL
    COPY
    MOVE

### <span style='color:red'>2.5 状态码</span>

    100-199 信息提示
        已定义范围 100-101
    200-299 标识成功
        已定义范围 200-206 成功
    300-399 资源已被移走
        已定义范围 300-305 重定向
    400-499 标识客户端请求出错
        已定义范围 400-415 客户端错误
    500-599 服务器出错
        已定义范围 500-505 服务端错误

    100（继续|Continue） 请求者应当继续提出请求。服务器返回此代码则意味着，服务器已收到了请求的第一部分，现正在等待接收其余部分。
    101（切换协议|Switching Protocols） 请求者已要求服务器切换协议，服务器已确认并准备进行切换。

    200（成功|OK）  服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果您的 robots.txt 文件显示为此状态，那么，这表示Googlebot已成功检索到该文件。
    201（已创建|Created）  请求成功且服务器已创建了新的资源。
    202（已接受|Accepted）  服务器已接受了请求，但尚未对其进行处理。
    203（非授权信息|Non-Authoritative Information）  服务器已成功处理了请求，但返回了可能来自另一来源的信息。
    204（无内容|No Content）  服务器成功处理了请求，但未返回任何内容。
    205（重置内容Reset Content） 服务器成功处理了请求，但未返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如清除表单内容以输入新内容）。
    # 206（部分内容|Partial Content）  服务器成功处理了部分 GET 请求。 断点续传可能会用到

    300（多种选择|Multiple Choices）  服务器根据请求可执行多种操作。服务器可根据请求者 (User agent) 来选择一项操作，或提供操作列表供请求者选择。
    301（永久移动|Moved Permanently）  请求的网页已被永久移动到新位置。服务器返回此响应（作为对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码通知 Googlebot 某个网页或网站已被永久移动到新位置。
    302（找到|Found） 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置。但由于 Googlebot 会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知 Googlebot 某个页面或网站已被移动。注意：在 HTTP 1.0中，302表示消息是临时移动(Moved Temporarily)的而不是被找到。
    303（参见其他信息|See Other） 这个状态码和 301、302 相似，只是如果最初的请求是 POST，那么新文档（在定位头信息中给出）药用 GET 找回。这个状态码是新加入 HTTP 1.1中的。
    304（未修改|Not Modified） 自从上次请求后，请求的网页未被修改过。服务器返回此响应时，不会返回网页内容。
    如果网页自请求者上次请求后再也没有更改过，您应当将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。由于服务器可以告诉 Googlebot 自从上次抓取后网页没有更改过，因此可节省带宽和开销。
    305（使用代理|Use Proxy） 请求者只能使用代理访问请求的网页。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。
    307（临时重定向|Temporary Redirect）  服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置。但由于 Googlebot 会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知 Googlebot 某个页面或网站已被移动。

    400（错误请求|Bad Request） 服务器不理解请求的语法。
    401（未授权|Unauthorized） 请求要求进行身份验证。登录后，服务器可能会返回对页面的此响应。
    403（已禁止|Forbidden） 服务器拒绝请求。如果在 Googlebot 尝试抓取您网站上的有效网页时显示此状态代码（您可在Google 网站管理员工具中诊断下的网络抓取页面上看到此状态代码），那么，这可能是您的服务器或主机拒绝 Googlebot 对其进行访问。
    404（未找到|Not Found） 服务器找不到请求的网页。例如，如果请求是针对服务器上不存在的网页进行的，那么，服务器通常会返回此代码。
    如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具”诊断”标签的 robots.txt 页上发现此状态，那么，这是正确的状态。然而，如果您有 robots.txt 文件而又发现了此状态，那么，这说明您的 robots.txt 文件可能是命名错误或位于错误的位置。（该文件应当位于顶级域名上，且应当名为 robots.txt）。
    如果您在 Googlebot 尝试抓取的网址上发现此状态（位于”诊断”标签的 HTTP 错误页上），那么，这表示 Googlebot 所追踪的可能是另一网页中的无效链接（旧链接或输入有误的链接）。
    405（方法禁用|Method Not Allowed） 禁用请求中所指定的方法。
    406（不接受|Not Acceptable） 无法使用请求的内容特性来响应请求的网页。
    407（需要代理授权|Proxy Authentication Required） 此状态代码与 401（未授权）类似，但却指定了请求者应当使用代理进行授权。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。
    408（请求超时|Request Timeout）  服务器等候请求时超时。
    409（冲突|Conflict）  服务器在完成请求时发生冲突。服务器必须包含有关响应中所发生的冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，同时会提供两个请求的差异列表。
    410（已删除|Gone）  如果请求的资源已被永久删除，那么，服务器会返回此响应。该代码与 404（未找到）代码类似，但在资源以前有但现在已经不复存在的情况下，有时会替代 404 代码出现。如果资源已被永久删除，那么，您应当使用 301 代码指定该资源的新位置。
    411（需要有效长度|Length Required） 服务器不会接受包含无效内容长度标头字段的请求。
    412（未满足前提条件|(Precondition Failed） 服务器未满足请求者在请求中设置的其中一个前提条件。
    413（请求实体过大|Request Entity Too Large） 服务器无法处理请求，因为请求实体过大，已超出服务器的处理能力。
    414（请求的 URI 过长|Request URI Too Long） 请求的 URI（通常为网址）过长，服务器无法进行处理。
    415（不支持的媒体类型|Unsupported Media Type） 请求的格式不受请求页面的支持。
    # 416（请求范围不符合要求|Requested Range Not Satisfiable） 如果请求是针对网页的无效范围进行的，那么，服务器会返回此状态代码。  断点续传
    417（未满足期望值|Expectation Failed） 服务器未满足”期望”请求标头字段的要求。


    500（服务器内部错误|Internal Server Error）  服务器遇到错误，无法完成请求。
    501（尚未实施|Not Implemented） 服务器不具备完成请求的功能。例如，当服务器无法识别请求方法时，服务器可能会返回此代码。
    502（错误网关|Bad Gateway） 服务器作为网关或代理，从上游服务器收到了无效的响应。
    503（服务不可用|Service Unavailable） 目前无法使用服务器（由于超载或进行停机维护）。通常，这只是一种暂时的状态。
    504（网关超时|Gateway Timeout）  服务器作为网关或代理，未及时从上游服务器接收请求。
    505（HTTP 版本不受支持|HTTP Version Not Supported） 服务器不支持请求中所使用的 HTTP 协议版本

## <span style='color:red'>3.首部</span>

### 3.1 通用首部

    首部                描述

    Connection          允许客户端和服务器指定与请求、响应连接的有关选项
    Date                时间
    MIME-Version        给出了发送端使用的MIME版本
    Transfer-Encoding   告知接收端为了保证报文的可靠传输，对报文采取了什么编码（当为chunked编码是不会存在Content-length）
    Update              给出了发送端可能想要升级是用的什么的编码方式
    Via                 显示报文经过的中间节点（代理、网关）
    # Cache-Control       用于随报文传送缓存指示            // 重点查看Cache-Control专题文章
    # Pragma              另一种随报文传送指示的方式，但并不专用缓存 （兼容 http 1.0）Pragma:no-cache 和 Cache-Control:no-cache相同
### 3.2 请求首部

    请求首部是只在请求报文中有意义的首部。

    首部                描述

    Client-IP           提供了运行客户端的机器ip地址
    From                提供了客户端用户的E-mail地址
    Host                给出了接收请求的服务器的主机名和端口号
    Referer             提供了包含当前请求URI的文档的URL
    UA-Color            提供了与客户端显示器的显示颜色相关的信息
    UA-CPU              给出了客户端CPU的类型或制造商
    UA-Disp             提供了与客户端显示器能力有关的信息
    UA-OS               给出了运行在客户端机器上的操作系统名称以及版本
    UA-Pixels           提供了客户端显示器的像素信息
    User-Agent          将发起请求的应用程序名称告知服务器

#### 3.2.1 Accept 首部

    Accept首部提供了一种将客户端的喜好和能力告知服务器的方式，包括他们想要什么，可以使用什么，以及最重要的是什么，不想要什么。
    Accept首部会使链接的两端都收益。
    客户端会得到他们想要的内容，服务器则不会浪费其时间带宽来发送无法使用的东西。

    首部                    描述

    Accept                  告诉我服务器能够发送那些媒体类型
    Accept-Charset          告诉服务器能够发送哪些字符集
    Accept-Encoding         告诉服务器能够发送哪些编码方式
    Accept-Language         告诉服务器能够发送那些语言
    TE                      告诉服务器可以使用哪些扩展传输编码

#### 3.2.2 条件请求首部

    有时客户端希望为了请求加上某些限制。比如，如果客户端已经有了一份文档副本，就希望只在服务器上的文档与客户端拥有的副本有所区别时，才请求服务器传输文档。通过条件请求首部客户端就可以为请求加上一些限制，要求服务器在对请求进行相应之前，确保某个条件为真。

    首部                    描述

    Expect                  允许客户端列出某请求所要求的服务器行为
    If-Match                如果实体标记与文档当前的实体标记相匹配，就获取这份文档。
    If-Modified-Sine        除非在某个指定的日期之后被就修改过，否则就限制这个请求。
    If-None-Match           如果提供的实体标记与当前文档的实体标记不相符，就获取文档。
    If-range                允许对文档的某个范围进行条件请求。
    If-Unmodified-Since     除非在某个指定日期之后资源没有被修改过，否则就限制这个请求
    # Range                   如果服务器支持范围请求，就请求资源的指定位置。（断点续传）

#### 3.2.3 安全请求首部

    HTTP本身就支持一种单间的机制，可以对请求进行质询/响应认证。这种机制要求客户端在获取特定的资源之前，先对自身进行认证，这样就可以事务稍微安全一些。

    首部                    描述

    Authorization           包含了客户端提供给服务器，以便对其自身进行认证的数据。
    Cookie                  客户端用它向服务器传送一个令牌 它并不是真正的安全首部，但确实隐含了安全功能。
    Cookie2                 用来说明请求端的cookie版本。

#### 3.2.4 代理请求首部

    首部                    描述

    Max-Forward             在通往的源端服务器的路径上，将请求转发给其他代理或网关的最大次数---与TRACE方法一同使用
    Proxy-Authorization     与Authorization首部相同，但这个首部是与代理进行认证时使用的
    Proxy-Connection        与Connection首部相同，但这个首部是与在代理建立连接时使用的。

### 3.3 响应首部

    首部                    描述

    Age                     响应持续时间
    Public                  服务器为其资源支持的请求方法列表
    Retry-After             如果资源不可用的话，在此日期活时间重试。
    Server                  服务器应用程序软件的名称和版本
    Title                   对HTML文档来说，就是HTML文档的源端给出的标题。
    Warning                 比原因短语更详细的一些警告报文

#### 3.3.1 协商首部

    如果资源有多种表示方法，可以为服务器和客户端提供资源进行协商的能力。

    首部                    描述

    Accept-Ranges           对此资源来说，服务可接受的范围类型
    Vary                    服务器查看的其他首部列表，可能会使响应发生变化，也就是说服务器会根据这些首部的内容挑选出最合适的资源版本发送给客户端。

#### 3.3.2 安全响应首部

    首部                    描述

    Proxy-Authenticate      来自代理的对客户端的质询列表
    Set-Cookie              不是真正的安全首部，但隐含有安全功能，可以在客户端设置令牌，以便服务器对客户端进行标识。
    Set-Cookie2             与Set-Cookie相似
    WWW-Authenticate        来自服务器对客户端的质询列表

### 3.4 实体首部

    实体的首部都可以用来描述HTTP报文的负荷，由于请求和响应报文中都可能包含实体部分，所以在这两种类型的报文中都可能出现这些首部。

    首部                    描述

    Allow                   列出了可以对此实体执行的请求方法
    Location                告知客户端实体实际上位于何处，用于将接收的资源定向到资源的位置上去URL

#### 3.4.1 内容首部

    首部                    描述

    Content-Base            解析主体中的相对URL时使用的基础URL
    Content-Encoding        对主体执行的任意编码方式
    Content-Language        理解主体时最适宜使用的自然语言
    Content-length          主体的长度或尺寸
    Content-Location        资源所处的实际位置
    Content-MD5             主体的MD5校验和
    Content-Range           在整个资源中此实体表示的字节范围
    Content-type            这个主体的对象类型


#### 3.4.2 实体缓存首部

    通用的缓存首部说明了如何或什么时候进行缓存。

    首部                    描述

    ETag                    与此实体相关的实体标记
    Expires                 实体不再有效，要从原始的源端再次获取此实体的日期和时间
    Last-Modified           这个实体最后一次被修改的日期和时间


# <span style='color:red'>7.连接管理</span>

    HTTP是如何使用TCP连接的
    TCP连接的时延、瓶颈以及存在的障碍。
    HTTP的优化，包括并行连接、keep-alive（持久连接）和管道化连接
    管理连接时应该以及不应该做的事。

## <span style='color:red'>7.1 TCP连接</span>

    TCP/IP是全球计算机以及网络设备都在使用的一种常用的分组交换网络分层协议集。一旦建立连接，在客户端和服务器的计算机之间交换的报文就永远不会丢失、受损或失序。
    步骤：
        1.浏览器解析出主机名
        2.浏览器查询这个主机名的IP地址（DNS解析）
        3.浏览器获取端口号
        4.浏览器发起到这个ip的端口80的连接
        5.浏览器向服务器发送一条HTTP GET报文
        6.浏览器从服务器读取http响应报文
        7.浏览器关闭连接

### 7.1.1 TCP的可靠管理通道

    HTTP连接实际上就是TCP连接和一些使用连接的规则。如果想要更加稳定以及更多快速的推荐查看TCP/IP详解。

    TCP为HTTP提供了一条可靠的比特传输管道。从TCP连接一端填入的字节会从另一端以原有的顺序、正确的传送出来。

    TCP会按序、无差错地承载HTTP数据

### 7.1.2 TCP流失分段的、由IP分组传送

    TCP的数据是通过名为IP分组或IP数据报的小数据块来发送的。HTTPS就是在HTTP和TCP之间插入了一个称之为TLS或SSL的密码加密层。

    HTTP：
        HTTP        应用层
        TCP         传输层
        IP          网络层
        网络接口    数据链路层

    HTTPS：
        HTTP            应用层
        TSL or SSL      安全层
        TCP             传输层
        IP              网络层
        网络接口        数据链路层

    HTTP要传送一条报文时，会以流的形式将报文数据的内容通过一条打开的TCP连接按序传输。TCP收到数据流之后，会将数据库砍成被称为段的小数据快，并将段封装在IP分组中，通过因特网进行传输。所有的工作都是由TCP/IP软件来完成。

    每个TCP端都是由IP分组承载，从一个IP地址发送到另一个IP
    地址。每个IP地址都包括：
        一个IP分组首部 （通常20字节）
        一个TCP段首部 （通常为20字节）
        一个TCP数据块（0-多个字节）
    IP首部包含了源和目的IP地址、长度和其他的一些标记。TCP段的首部包含了TCP的端口号、TCP控制标记，以及用于数据排列和完整性检查的一些数字值。

### 7.1.3 保持TCP连接的正确运行

    在任意时刻计算机都可以有几条TCP连接处于打开状态。TCP是通过端口号来保持连接的。
    端口号和雇员使用的电话分机很类似。就像公司的总机号码能将你接到前台,而分机号可以将你接到正确的雇员位置一样。IP地址可以将你连接到正确的计算机，而端口号则可以将你连接到正确的应用程序上。
        <源IP地址、源端口号、目的IP地址、目的端口号>
    这四个值一起唯一的定义了一条链接，两条不同的TCP链接不能拥有四个完全相同的地址组件值（但是不同的链接的部分组件可以拥有相同的值）

    举例：
        连接         源地址IP       源端口        目的ip地址        目的端口
        A           xx.xx.xx.xx    2034         xx.xx.xx.xx     4133
        B           xx.xx.xx.xx    3105         xx.xx.xx.xx     4140
### 7.1.4 用套接字编程

    对TCP连接进行编程所需的常见套接字接口函数
        s=socket(<parameters>)              创建一个新的、未命名、未关联的套接字
        bind(s,<local IP:port>)             向套接字赋一个本地端口号和接口
        connect(s,<remote IP:port>)         创建一条连接本地套接字与远程主机及端口的连接
        listen(s,...)                       标识一个本地套接字，使其可以合法的接受连接。
        s2=accept(s)                        等待某人建立一条到本地端口的连接
        n= read(s,buffer,n)                 尝试从套接字中向缓冲区中读取n个字节
        n=write(s,buffer)                   尝试从缓冲区中向套接字写入n个字符
        close(s)                            完全关闭TCP连接
        shutdown(s,<side>)                  只关闭TCP连接的输入和输出端
        getsocket(s,....)                   读取某个内部套接字配置选项的值
        setsockopt(s,....)                  修改某个内部套接字配置选项的值
    套接字API允许用户创建TCP的端点数据结构，将这些端点与远程服务器的TCP端点进行连接，并对数据流进行读写。TCP API隐藏了所有底层网络协议的握手细节，以及TCP数据流与IP分组之间的分段和重装细节。

    通讯流程：
        我们从WEB服务器等待链接，启动服务。客户端根绝URL判断出IP地址和端口号，并建立一条到服务器的TCP连接。建立连接的时间取决于，服务器的远近、服务器的负载，以及因特网的拥挤程度。
        建立连接后，客户端就会发送HTTP请求，服务器则会读取请求。一旦服务器获取了整条请求报文，就会对请求进行处理，执行所请求的动作，并将数据写回客户端。客户端读取数据，并对响应数据进行处理。

## <span style='color:red'>7.2 对TCP性能的考虑</span>

    HTTP紧挨着TCP，位于其上层，所以HTTP事务的性能在很大程度上取决于底层TCP通道的性能。
    HTTP事务的顺延
        这些TCP网络时延的大小取决于硬件速度、网络和服务器的负载，请求和响应报文的尺寸，以及客户端和服务器之间的距离。TCP协议的技术复杂性也会对时延产生巨大的影响。

### 7.2.1 TCP连接的握手延时

    TCP连接握手需要经过一下几个步骤:

        1.请求新的TCP连接时，客户端要向服务器发送一个小的TCP分组（40-60个字节）。这个分组中设置了一个特殊的SYM标记，说明这是一个连接请求。
        2.如果服务器接受了连接，就会对一些连接参数进行计算，并向客户端回送一个TCP分组。这个分组中的SYN和ACK标记都被置位，说明连接请求已被接受。
        3.最后，客户端向服务器回送一条确认消息，通知它已成功建立。现在的TCP栈都允许客户端在这个确认分组中发送数据。

### 7.2.2 延迟确认

    由于因特网自身无法确保可靠的分组传输，所以TCP实现了自己的确认机制来确保数据的成功传输。

    每个TCP段都有一个序列号和数据完整性校验和。每个段的接受者收到完好的段时，都会向发送者回送小的确认分组。如果发送者没有在指定窗口时间内收到确认信息，发送者就认为分组已被破坏，并重新发送数据。

### 7.2.3 TCP慢启动

    TCP数据传输的性能还取决于TCP连接的使用期。TCP连接会随着时间进行自我调谐，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输速度。这种调谐被称为TCP连接的慢启动。用于防止因特网的突然过载和拥塞。

    TCP慢启动限制了TCP断点在任意时刻可以传输的分组数。每成功接受一个分组，发送端就有了发送另外两个分组的权限。如果某个HTTP事务有大量数据要发送时，是不能一次将所有的发送的。必须发送一个分组，等待确认，然后可以发送两个分组，每个分组被确认后，这样就可以发送四个分组，依次类推。这种方式被称为     打开拥塞窗口。
    所以新连接要比已经交换过的要慢。

### 7.2.4 Nagle算法与TCP_NODELAY 详情查看收藏文章

### 7.2.5 TIME_WAIT累积与端口耗尽

    TIME_WAIT端口耗尽是严重的性能问题，会影响到性能基准。当某个TCP端点关闭TCP链接时，会在内存中维护一个小的控制块。用来记录最近关闭链接的的IP地址和端口号。这类信息只会维持一小段时间，通常是所估计的最大分段使用期的两倍左右。以确保在这段时间内不会创建具有相同地址和端口号的新连接。

## 7.3 HTTP连接的处理

### <span style='color:red'>7.3.1 常被误解的Connection首部 待补充 Connection内容</span>

    HTTP允许在客户端和最终的源服务器之间存在一串HTTP中间实体（代理、高速缓存）。可以从客户端开始，逐跳地将HTTP报文经过这些中间设备，转发到源服务器上。在某些情况下，两个相邻的的HTTP应用程序会为他们共享的连接应用一组选项。HTTP的Connection首部字段中有一个逗号分隔的连接标签列表，这些标签为此链接指定了一些不会传播的到其他连接中的选项。
    可以承载三种不同类型的标签：
        HTTP首部字段，列出了只与此链接有关的首部。
        任意标签值，用于描述此链接的非标准选项。
        值close，说明操作完成之后需要关闭这条持久连接。

    如果连接标签包含了一个HTTP首部字段名称，那么首部字段就包含了与一些连接有关的信息。不能将其转发出去。在将报文转发出去之前，必须删除Connection首部列表的所有首部字段。由于Connection首部可以防止无意中对本地首部的转发。因此将逐跳首部名放入Connection首部被称为 对首部的保护

    EX:
        首部说明：不应该转发Meter首部，要应用假象的bill-my-credit-card选项，且本次事务结束之后应关闭持久连接。
        HTTP/1.1 200 ok
        Cache-control:max-age=3600
        Connection:meter,close,bill-my-credit-card
        Meter:max-uses=3,max-refues=6,dont-report

### 7.3.2 串行事务处理延时

    串行的请求http（不可行）

### 7.4 并行连接

    可能不一定快，消耗带宽，消耗内存

### 7.5 持久连接

    Web客户端经常会打开到同一个站点的连接。初始化了对某服务器HTTP请求的应用程序很可能会在不久的将来对那台服务器发起更多的请求，比如获取在线的图片。这种性质被称为站点的本质性。
    在事务处理完成之后仍然保持在打开状态的TCP连接被称为持久连接。重用已对目标服务器打开的空闲的持久连接。就可以避免缓慢的连接建立阶段。而且已经打开的连接还可以避免慢启动的拥塞适应阶段。以便更快的进行数据传输。

#### 7.5.1 持久和并行连接

    并行连接缺点。
        每个事务都会打开、关闭一条新的连接，会耗费时间和带宽。
        由于TCP慢启动特性的存在，每条新连接的性能都会有所下降。
        可打开的并行连接数量实际上是有限的。
    持久连接降低了时延和连接建立的开销。将连接保持在已调谐状态。而且减少了打开连接的数量。最好的方案就是配合使用。

#### 7.5.2 HTTP/1.0+keep-alive 连接
<img src='https://dpq123456-1256164122.cos.ap-beijing.myqcloud.com/HTTP/1520489859252_%E5%9B%9B%E4%B8%AA%E4%BA%8B%E5%8A%A1%EF%BC%88%E4%B8%B2%E8%A1%8C%E4%B8%8E%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5%EF%BC%89.png' width='400px' />

#### 7.5.3 Keep-Alive操作

    keep-alive已经在业务场景下不再使用，但是针对浏览器和服务器之间交互用的依据很多。

#### 7.5.4 keep-Alive 选线

    keep-Alive 首部只是请求连接保持在活跃状态。发出keep-alive请求之后，客户端和服务端并不一定会同意进行keep-Alive会话。他们可以在任意时刻关闭空闲的keep-Alive连接。并可随意的限制keep-alive连接所处理的事务的数量。

    Keep-Alive首部是可选的，但只有在提供Connection:Keep-Alive时才能使用它，这个例子说明服务器最多还会为另外五个事务保持连接的打开状态，或者将打开状态保持到连接空闲了2分钟之后。
        Connection:Keep-Alive
        Keep-Alive:max=5,timeout=120

#### <span style='color:red'>7.5.5 Keep-Alive连接的限制和规则<span/>

    1.Keep_Alive http1.0 不默认使用 需要加Connection:Keep-Alive
    2.Connection:Keep-Alive 首部必须随所有希望保持持久连接的报文一起发送。
    3.客户端探明响应中没有Connection:Keep-Alive 响应首部，就可以知道服务器发出响应之后是否关闭连接了。
    4.只有在无需检测到连接的关闭即可确定报文实体主体部分长度的情况下，才能将连接保持在打开状态。也就是说主体部分的Content-length是正确的。如果错误会导致事务处理的另一端无法精确地检测数一条报文的结束和另一条报文的开始。
    5.代理和网关必须执行Connection首部的规则。代理和网关必须在将报文转发出去或者其高速缓存之前，删除在Connection首部中命名的所有首部字段以及Connection首部自身。
    6.严格来说，不应该与无法确定是否支持Connection首部的代理服务器建立keep-alive连接，以防止出现下面要介绍的哑代理。在实际应用中不是总能做到这一点的。
    7.从技术来讲，应该忽略所有来自HTTP/1.0设备的Connection首部字段（包括Connection：keep-alive）,因为他们可能是由比较老的代理服务器误转发的。但是实际上，尽管可能会在老代理挂起的危险。

#### <span style='color:red'>7.5.6 Keep-Alive和哑代理<span/>
    没有代理的流程应该是：
        客户端发送带有Connection：Keep-Alive 请求->如果服务器支持就回送一个Connection：Keep-Alive，否则就不回送。
    1.Connection首部和盲中继
        问题出在代理上-尤其是那些不理解的Connection首部。而且不知道在沿着转发连接将其发送出去之后，应该将首部删除的代理。很多老的或简单的代理都是盲中继，他们只是字节从一个连接转发另一个连接中去，不对Connection首部进行特殊的处理。
    图解：
<img src='https://dpq123456-1256164122.cos.ap-beijing.myqcloud.com/HTTP/1520567004_Keep-Alive%E6%97%A0%E6%B3%95%E4%B8%8E%E4%B8%8D%E6%94%AF%E6%8C%81Connnection%E9%A6%96%E9%83%A8%E7%9A%84%E4%BB%A3%E7%90%86%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C.png' width='500px'/>

    上图说明了一下集中情况：
        1.Web客户端向代理发送了一条报文，其中包括了Connection：Keep-Alive首部。如果可能的话请求建立一条keep-alive连接。客户端等待响应，以确定对方是否认可它对keep-alive信道的请求。
        2.哑代理收到了这条HTTP请求，但它并不理解Connection首部（只能将其作为一个扩展首部对待）。代理不知道keep-alive什么意思，因此只是沿着转发链接将报文一字不漏的发送给服务器。但Connection首部是个逐条首部，只适合用于单条传输链路，不应该沿着传输链路向下传输。
        3.当代理转发keep-alive Connection首部后服务器会认为客户端需要keep-alive。所以服务器会进行keep-alive请求。
        4.当服务端响应时并将Connection:Keep-Alive返回给客户端时，客户端查看到就会同意keep-alive连接。
        5.由于代理对keep-alive一无所知，所以会将收到的数据都回送给客户端，然后等待源服务器关闭连接，但源服务器会认为代理已经显式地请求它将连接的保持在打开状态了，所以不会关闭连接。这样代理就会挂在哪里等待连接的关闭。
        6.客户端收到了回送的响应报文时，会立即转向下一条请求，在keep-alive连接上向代理发送另一条请求（复用）。而代理并不认为同一条连接上会有其他请求到来，请求被忽略，浏览器j就会在哪里转圈。
        7.这种错误只会等待连接超时，并将其关闭。

    2.代理和隧道首部

        现在的代理绝不转发Connection中出现的首部或者包括keep-alive的首部。还有几个包括 Proxy-Authenticate，Proxy-Connection、Transfer-Encoding和Upgrade

#### <span style='color:red'>7.5.7 插入Proxy-Connection 查看收藏文章<span/>
<img src='https://dpq123456-1256164122.cos.ap-beijing.myqcloud.com/HTTP/1520584237_Proxy-Connection%E9%A6%96%E9%83%A8%E4%BF%AE%E6%AD%A3%E4%BA%86%E5%8D%95%E4%B8%AA%E7%9B%B2%E4%B8%AD%E7%BB%A7%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98.png' width='400px'/>
<img src='https://dpq123456-1256164122.cos.ap-beijing.myqcloud.com/HTTP/1520584294_%E5%AF%B9%E6%9C%89%E5%A4%9A%E5%B1%82%E6%AC%A1%E4%BB%A3%E7%90%86%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8CProxy-Connection%E4%BB%8D%E7%84%B6%E6%97%A0%E6%B3%95%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98.png' width='400px'/>

####  7.5.8 HTTP/1.1 持久连接

    HTTP/1.1 逐渐停止了对keep-alive连接的支持，用一种持久连接改进机制替换了。所以现在大部分都是默认持久连接，如果要关闭需要在Connection:close。但是客户端和服务端可以随时关闭连接。

#### 7.5.9 持久连接的限制和规则

    1.发送了Connection：close请求首部之后，客户端就无法在那条连接上发送更多的请求了。
    2.只有当所有的报文都有正确的、自定义报文长度时。实体主体部分的长度都和相应的Content-Length一致，或者是用分块传输编码方式编码-连接才能持久。
    3.HTTP/1.1 的代理必须能够分别管理与客户端和服务器的持久连接----每个持久连接都适用于一跳传输。
    4.HTTP1.1的代理服务器不应该与HTTP1.0客户端建立持久连接，除非他们了解客户端的处理能力。
    5.尽管服务器不应该试图在传输报文的过程中关闭连接，而且在关闭连接之前至少应该响应一条请求，但不管Connection首部去了什么值，HTTP/1.1 设备都可以在任意时刻关闭连接。
    6.HTTP/1.1 应用程序必须能够在异步的关闭中恢复出来。只要不存在可能会积累起来的副作用。客户端都应该重试这条请求。
    7.除非重复发起请求会产生副作用，否则如果在客户端收到整条响应之前连接关闭了，客户端就必须要重新发起请求。
    8.一个用户客户端对任何服务器或者代理最多只能维护两条持久连接，以防止服务器过载。代理可能需要更多到服务器的连接来支持并发用户的通信，所以，如果有N个用户试图访问服务器时，代理最多要维持2N条到任意服务器或副代理连接。

### 7.6 管道化连接

    HTTP/1.1 允许在持久连接上使用管道。在响应到达之前，可以将多条放入队列中。当第一条请求通过网络流向地球的另一端的服务器时，第二条和第三条请求也可以开始发送了。在高延时的网络条件下降低网络的回环时间，提高性能。

        限制：
            1.如果HTTP客户端无法确认连接是持久的，就不应该使用管道。
            2.必须按照与请求相同的顺序回送HTTP响应。HTTP报文中没有序列号标签。因此如果收到的响应失序了，就没办法将其与请求匹配起来了。
            3.HTTP管道必须做好在任意时刻关闭的准备，还要准备好重新发送未完成的管道请求。同时十条五条响应后关闭连接，剩余五条需要重新发送。
            4.HTTP客户端不应该用管道化的方式发送会产生副作用的请求。如果出错，无法安全的重试POST这样的非幂等请求，所以出错后，就存在某些方法永不会执行的风险。
<img src='https://dpq123456-1256164122.cos.ap-beijing.myqcloud.com/HTTP/1520825438_4%E4%B8%AA%E4%BA%8B%E5%8A%A1%EF%BC%88%E7%AE%A1%E9%81%93%E5%8C%96%E8%BF%9E%E6%8E%A5%EF%BC%89.png' width='500px'/>

### 7.7 关闭连接的奥秘

#### 7.7.1 "任意"解除连接

    所有HTTP客户端、服务器或者代理都可以在任意时刻关闭一条TCP传输连接。但是出错的时候，也可能在首部行的中间，或其他奇怪的地方关闭连接。但是服务器永远都无法确定在她关闭的空闲连接的那一刻，在线路的那一头的客户端有没有数据要发送。如果出现这种情况客户端就会在写入半截请求报文时出现连接错误。

#### 7.7.2 Content-Length及截尾操作

    每条HTTP响应的都应该有精确的Content-Length首部，用于描述主体的尺寸。除了response首部的chunk。

#### 7.7.3 连接关闭容限、重试以及幂等性

    如果一个事务，不管是执行一次还是很多次，得到的结果都相同。这个事务就是幂等的。实现者可以认为GET、HEAD、PUT、DELETE、TRACE和OPTIONS方法都共享这一特性。客户端不应该以管道化方式传送非幂等请求（POST），否则，传输连接的过早终止就会造成一些不确定的后果。要发送一条非幂等请求，就需要等待来自前一条请求的响应状态。大多数浏览器都会在重载一个缓存的POST响应时提供一个对话框，询问用户是否希望再次发起事务处理。

#### 7.7.4 正常关闭连接

    TCP连接时双向的。TCP连接的每一端都有一个输入、输出队列，用户数据的读和写。放入一端的输出队列的数据最终会出现在另一端的输入队列中。
<img src='https://dpq123456-1256164122.cos.ap-beijing.myqcloud.com/HTTP/1520836369_TCP%E8%BF%9E%E6%8E%A5%E6%98%AF%E5%8F%8C%E5%90%91%E7%9A%84.png' width='500px'/>

    1.完全关闭与半关闭
        应用程序可以关闭TCP输入和输出信道中的任意一个，或者两者都关闭了。套接字调用close()会将TCP连接的输入和输出信道都关闭了。这被称为完全关闭，还可以使用套接字调用shutdown()单独关闭输入和输出信道。这被称为半关闭。

<img src='https://dpq123456-1256164122.cos.ap-beijing.myqcloud.com/HTTP/1520838955_%E5%AE%8C%E5%85%A8%E5%85%B3%E9%97%AD%E5%92%8C%E5%8D%8A%E5%85%B3%E9%97%AD.png' width='500px' />

    2.TCP关闭及重置错误

        简单的HTTP应用程序可以只使用完全关闭。但当应用程序开始与很多其他类型的HTTP客户端、服务器和代理进行对话且开始使用管道化持久连接时，使用半关闭来防止对等实体收到非预期的写入错误就变的很重要。
        关闭输出是安全的，关闭输入是危险的，因为不知道客户端或者服务器会不会发数据。如果另一端向你已关闭的输入信道发送数据，操作系统就会向另一端的机器回送一条TCP，连接被重置的报文。

    3.正常关闭

        实现正常关闭的应用程序首先先关闭他们的输出通道，然后等待连接另一端的对实体关闭它的输出通道。当两端都告诉对方不会再有发任何数据之后，连接就会被完全关闭，而不会有重置的危险。想要正常关闭连接的应用程序应该先关闭其输出通道，然后周期性地检查其输入通道的状态（查找数据、或流的末尾）。

### 7.8 更多 （TCP/IP详解）

# 8.Web服务器
# 9.代理
## 9.1 Web的中间实体
### 9.1.1 代理和网关的对比

    严格来说，代理连接是两个或多个相同协议的应用程序，而网关连接的则是两个或者使用不同协议的端点。网关扮演的是 协议转换器 的角色。即使客户和服务器使用不同的协议。客户端也可以通过他完成与服务器之间的事务处理。
<img src='https://dpq123456-1256164122.cos.ap-beijing.myqcloud.com/HTTP/1522217867_%E4%BB%A3%E7%90%86%E7%BD%91%E5%85%B3%E7%9A%84%E5%AF%B9%E6%AF%94.png' width='400px'/>
    实际上，代理和网关之间的区别很模糊。由于浏览器和服务器实现的是不同版本的HTTP,代理也经常做一些功能来支持协议转换工作。而商业化的代理服务器也会实现网关的功能来支持SSL安全协议、SOCKS防火墙、FTP访问，以及基于Web应用程序。
## 9.2 为什么使用代理

    改善安全性，提供性能，节省费用
    儿童过滤器
    文档访问控制
    安全防火墙
    Web缓存
<img src='https://dpq123456-1256164122.cos.ap-beijing.myqcloud.com/HTTP/1522218719_Web%E7%BC%93%E5%AD%98.png' width='400px'/>
    反向代理
<img src='https://dpq123456-1256164122.cos.ap-beijing.myqcloud.com/HTTP/1522218823_%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8A%A0%E9%80%9F%E7%9A%84%E6%9B%BF%E4%BB%A3%E7%89%A9.png' width='400px'/>
    内容路由器
        代理服务器可以作为内容路由器使用，根据因特网流量状况以及内容类型将请求导向特定的Web服务器。
<img src='https://dpq123456-1256164122.cos.ap-beijing.myqcloud.com/HTTP/1522219270_%E5%86%85%E5%AE%B9%E8%B7%AF%E7%94%B1%E5%99%A8.png' width='400px'/>
    转码器
        代理服务器将内容发送给客户端之前，可以修改内容的主体格式，进行透明转换称为转码。
        可以对图片或者文本进行压缩 或者转码比如GIF-JPEG
<img src='https://dpq123456-1256164122.cos.ap-beijing.myqcloud.com/HTTP/1522219571_%E5%86%85%E5%AE%B9%E8%BD%AC%E7%A0%81%E5%99%A8.png' width='400px'/>

    匿名者
        匿名者代理主动从http报文中删除身份特性（比如客户端IP地址、From首部、Referer首部、cookie、URI的会话ID），从而提供高度的私密性和匿名性。
<img src='https://dpq123456-1256164122.cos.ap-beijing.myqcloud.com/HTTP/1522220168_%E5%8C%BF%E5%90%8D%E8%80%85.png' width='400px'/>

## 9.3 代理会去往何处

### 9.3.1 代理服务器的部署

    出口代理
    访问（入口）代理
    反向代理
    网络交换代理

#### 9.3.2 代理的层次结构


<img src='https://dpq123456-1256164122.cos.ap-beijing.myqcloud.com/HTTP/1522222010_%E4%BB%A3%E7%90%86%E9%83%A8%E7%BD%B2_%E4%B8%89%E7%BA%A7%E4%BB%A3%E7%90%86%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png' width='400px'/>

    几个动态选择父代理的例子
        负载均衡
        地理位置附近的路由
        协议/类型路由
        基于订购的路由

#### 9.3.3 代理是如何获取流量的

    修改客户端
    修改网络
        基础设施等
    修改DNS的命名空间

    修改Web服务器
<img src='https://dpq123456-1256164122.cos.ap-beijing.myqcloud.com/HTTP/1522226138_%E4%BB%A3%E7%90%86%E6%98%AF%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%B5%81%E9%87%8F%E7%9A%84.png' width='400px'/>

### 9.4 客户端的代理配置

    手工配置
    预先配置浏览器
    代理的自动配置 PAC
    WPAD的代理发现

#### <span style='color:red'>9.4.1 代理URI和服务器URI的不同</span>

    客户端向Web服务器发送请求时，请求行中只包括部分URI（没有方案、主机或者端口）
    但是当客户端向代理发送请求时，请求行中则包括完整的URI。

    反向代理客户端是否识别的，因此会发送部分URI。

#### 9.4.2 URI的客户端自动扩展和主机名解析

    根据是否有代理，浏览器对请求的URI的解析会所有不同。没有代理时，浏览器会获得你输入的URI，尝试着寻找相应的IP地址。如果找到了主机名，浏览器会尝试相应的IP地址直到获得成功的连接为止。

    但是如果没有找到主机，很多浏览器都会尝试提供某种主机名自动扩展机制，以防用户输入的是主机简短的缩写形式。

        很多浏览器会尝试加入前缀www.和后缀.com，以防用户只输入了常见Web站点名的中间部分。

        有些浏览器甚至会将未解析出来的URI传递给第三方站点，这个站点会尝试着校正拼写错误，并给出一些用户可能希望访问的URI建议。

### 9.5追踪报文


>如有侵权行为，请[点击这里](https://github.com/cooper-q/MattMeng_hexo/issues)联系我删除

>[如发现疑问或者错误点击反馈](https://github.com/cooper-q/MattMeng_hexo/issues)

# 备注

>2019年9月9日

- 重新排版POST与GET的区别、增加基本的区别信息
